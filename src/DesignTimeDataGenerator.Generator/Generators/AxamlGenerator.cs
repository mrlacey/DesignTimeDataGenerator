using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp;

namespace DesignTimeDataGenerator.Generator
{
    [Generator]
    public class AxamlGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var additional = context.AdditionalTextsProvider
                .Where(at => at.Path.EndsWith(".axaml", StringComparison.OrdinalIgnoreCase));

            var info = additional.Select((at, ct) =>
            {
                var text = at.GetText(ct);
                var content = text?.ToString() ?? string.Empty;
                var lineCount = text?.Lines.Count ?? 0;
                var name = Path.GetFileNameWithoutExtension(at.Path);

                // Parse XML and collect DataType sections and their binding-like descendants
                var sections = new List<DataTypeSection>();
                try
                {
                    var xml = XDocument.Parse(content, LoadOptions.PreserveWhitespace | LoadOptions.SetLineInfo);
                    // Assume x namespace prefix is the XAML XAML namespace; common URI
                    XNamespace xNs = "http://schemas.microsoft.com/winfx/2006/xaml";

                    foreach (var elem in xml.Descendants())
                    {
                        var dataTypeAttr = elem.Attribute(xNs + "DataType");
                        if (dataTypeAttr != null)
                        {
                            var dtName = dataTypeAttr.Value;
                            var holders = new List<BindingHolder>();
                            // search all descendants of this element
                            foreach (var desc in elem.Descendants())
                            {
                                foreach (var attr in desc.Attributes())
                                {
                                    var v = attr.Value?.Trim();
                                    if (!string.IsNullOrEmpty(v) && v.StartsWith("{") && v.EndsWith("}"))
                                    {
                                        holders.Add(new BindingHolder(GetElementPath(desc), desc.Name.LocalName, attr.Name.LocalName, v));
                                    }
                                }
                            }
                            sections.Add(new DataTypeSection(dtName, GetElementPath(elem), holders));
                        }
                    }
                }
                catch
                {
                    // ignore XML parse errors; treat as no sections
                }

                return new AxamlInfo(at.Path, name, content, lineCount, sections);
            });

            context.RegisterSourceOutput(info, (spc, data) =>
            {
                var className = MakeIdentifier(data.Name);
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine($"// Source: {data.Path}");
                sb.AppendLine($"// Lines: {data.LineCount}");
                sb.AppendLine("// DataType sections detected: " + data.Sections.Count);
                foreach (var sec in data.Sections)
                {
                    sb.AppendLine($"//   DataType: {sec.DataType} at {sec.ElementPath} -> {sec.Holders.Count} binding-like attributes");
                    foreach (var h in sec.Holders)
                    {
                        sb.AppendLine($"//     {h.ElementName}.{h.AttributeName} = {h.Value}");
                    }
                }
                sb.AppendLine("using System;");
                sb.AppendLine();
                sb.AppendLine("namespace DesignTimeDataGenerator.Generated");
                sb.AppendLine("{");
                sb.AppendLine($"    public partial class {className}");
                sb.AppendLine("    {");
                sb.AppendLine("    }");
                sb.AppendLine("}");
                spc.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });
        }

        private static string MakeIdentifier(string name)
        {
            if (string.IsNullOrEmpty(name)) return "AxamlFile";
            var sb = new StringBuilder();
            if (!SyntaxFacts.IsIdentifierStartCharacter(name[0]))
                sb.Append('_');
            foreach (var ch in name)
            {
                sb.Append(SyntaxFacts.IsIdentifierPartCharacter(ch) ? ch : '_');
            }
            return sb.ToString();
        }

        private class AxamlInfo
        {
            public string Path { get; }
            public string Name { get; }
            public string Content { get; }
            public int LineCount { get; }
            public List<DataTypeSection> Sections { get; }

            public AxamlInfo(string path, string name, string content, int lineCount, List<DataTypeSection> sections)
            {
                Path = path;
                Name = name;
                Content = content;
                LineCount = lineCount;
                Sections = sections ?? new List<DataTypeSection>();
            }
        }

        private class DataTypeSection
        {
            public string DataType { get; }
            public string ElementPath { get; }
            public List<BindingHolder> Holders { get; }

            public DataTypeSection(string dataType, string elementPath, List<BindingHolder> holders)
            {
                DataType = dataType;
                ElementPath = elementPath;
                Holders = holders ?? new List<BindingHolder>();
            }
        }

        private class BindingHolder
        {
            public string ElementPath { get; }
            public string ElementName { get; }
            public string AttributeName { get; }
            public string Value { get; }

            public BindingHolder(string elementPath, string elementName, string attributeName, string value)
            {
                ElementPath = elementPath;
                ElementName = elementName;
                AttributeName = attributeName;
                Value = value;
            }
        }

        private static string GetElementPath(XElement elem)
        {
            var names = new Stack<string>();
            XElement current = elem;
            while (current != null)
            {
                names.Push(current.Name.LocalName);
                current = current.Parent;
            }
            return string.Join("/", names);
        }
    }
}
